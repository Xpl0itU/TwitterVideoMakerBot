import faster_whisper
import json
import ffmpeg
from datetime import timedelta, datetime

DEBUG = False  # Change it to show debug information


def add_subtitles(video_path: str, subtitles_path: str, output_path: str) -> None:
    """
    Add subtitles to a video.
    :param video_path: Path to the video file.
    :param subtitles_path: Path to the subtitles file.
    :param output_path: Path to the output file.
    """
    # Customize subtitles with this filter
    subtitle_filter = (
        f"subtitles='{subtitles_path}':"
        f"force_style='Fontsize=18,"  # Font Size
        f"PrimaryColour=&HFFFFFF&,"  # Font Color in BGR format or ABGR format
        f"Alignment=6,"  # Top Center Alignment
        f"MarginL=0,"  # Offset Left
        f"MarginR=0,"  # Offset Right
        f"MarginV=200'"  # Vertical Offset
    )

    # Codecs configuration
    video_codec = "libx264"
    audio_codec = "aac"

    # Output options
    output_options = {"vf": subtitle_filter, "c:v": video_codec, "c:a": audio_codec}

    # Render the video
    ffmpeg.input(video_path).output(output_path, **output_options).run(
        quiet=True, overwrite_output=True, capture_stdout=False, capture_stderr=False
    )


def generate_srt(subtitles: list) -> str:
    timestamp_format = datetime.strptime(
        "00:00:00,000", "%H:%M:%S,%f"
    )  # Null element of addition to keep the timestamp format
    srt = str()
    for i, subtitle in enumerate(subtitles):
        start_time = (subtitle["start_time"] + timestamp_format).strftime(
            "%H:%M:%S,%f"
        )[:-3]
        end_time = (subtitle["end_time"] + timestamp_format).strftime("%H:%M:%S,%f")[
            :-3
        ]
        words = subtitle["words"]

        srt += f"{i+1}\n"
        srt += f"{start_time} --> {end_time}\n"
        srt += " ".join(words) + "\n\n"

    return srt


def append_segment_to_subtitles(subtitles: list, segment: tuple) -> list:
    """
    Append segment to subtitles.
    :param subtitles: Subtitles list.
    :param segment: Segment to append.
    :return: Subtitles list.
    """
    if DEBUG:
        print(f"{segment.end} | {segment.end} | {segment.end}")
    # Calculate end_time for each word
    start_time = timedelta(seconds=segment.start)
    end_time = timedelta(seconds=segment.end)
    # Create subtitle for each word
    subtitle = {
        "start_time": start_time,
        "end_time": end_time,
        "words": [segment.word],
    }
    subtitles.append(subtitle)
    return subtitles


def transcribe_audio(audio_path: str, srt_path: str, word_by_word: bool = True) -> None:
    """
    Transcribe audio file to SRT file.
    :param audio_path: Path to the audio file.
    :param srt_path: Path to the SRT file.
    :param word_by_word: If True, the subtitles will be generated by each word.
    """
    model = faster_whisper.WhisperModel(
        "base"
    )  # You can choose: [tinu, base, small, medium] to more accurate subtitles
    transcribe = model.transcribe(audio=audio_path, word_timestamps=True)
    segments = transcribe[0]
    if DEBUG:
        with open("transcribe_dump.txt", "w") as arq:
            arq.writelines(json.dumps(transcribe, indent=2))
    subtitles = list()
    for segment in segments:
        # Segment Information
        words = segment.words
        if word_by_word:
            for word in words:
                subtitles = append_segment_to_subtitles(subtitles, word)
        else:
            subtitles = append_segment_to_subtitles(subtitles, segment)

    # Gererate the SRT File
    srt_content = generate_srt(subtitles)

    # Write the SRT File
    with open(srt_path, "w", encoding="utf-8") as file:
        file.write(srt_content)

    print("Subtitles were generated with success!")
